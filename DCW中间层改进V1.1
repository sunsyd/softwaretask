具体代码
import uuid
import queue
import threading
import requests
from flask import Flask, request, jsonify

app = Flask(__name__)

# 请求队列和结果映射池
request_queue = queue.Queue()
result_pool = {}

# 后端服务地址（示例）
BACKEND_URL = "http://localhost:8000/calculate"

# 处理函数：转发请求至后端并接收响应
def worker():
    while True:
        item = request_queue.get()
        if item is None:
            break
        user_id, payload = item
        try:
            response = requests.post(BACKEND_URL, json=payload, timeout=5)
            result = response.json()
            result_pool[user_id] = result
        except Exception as e:
            result_pool[user_id] = {"error": str(e)}
        request_queue.task_done()

# 启动后台线程处理请求
threading.Thread(target=worker, daemon=True).start()

# 接收前端请求接口
@app.route("/api/compute", methods=["POST"])
def handle_request():
    data = request.get_json()
    expression = data.get("expression")
    unit = data.get("unit", "rad")

    # 生成唯一 ID
    user_id = str(uuid.uuid4())

    # 构造完整请求体
    payload = {
        "expression": expression,
        "unit": unit,
        "ID": user_id
    }

    # 放入消息队列等待处理
    request_queue.put((user_id, payload))

    # 等待后端计算完成（最多等待 3 秒）
    timeout = 3
    waited = 0.0
    while user_id not in result_pool and waited < timeout:
        threading.Event().wait(0.1)
        waited += 0.1

    # 提取结果
    if user_id in result_pool:
        result = result_pool.pop(user_id)
        return jsonify(result)
    else:
        return jsonify({"error": "Timeout waiting for result."}), 504

if __name__ == "__main__":
    app.run(port=5000, debug=True)

-------------------------------------------------------------------------------------------------------------------------
内容包括：
1.接收前端请求（包含表达式和单位）；

2.为每个请求生成唯一 ID；

3.将请求放入消息队列中；

4.后台线程将请求发送到后端服务；

5.接收后端响应后根据 ID 返回结果给前端。





